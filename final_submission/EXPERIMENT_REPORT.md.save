#实验报告
## 一、实验环境搭建过程

### 1.1 虚拟机安装与配置
- 本次实验使用VMware Workstation虚拟化软件安装Ubuntu 22.04 LTS操作系统。虚拟机配置为4GB内存，40GB硬盘空间和2核CPU，确保有足够的资源运行排序算法和性能测试。

- 安装过程包括下载Ubuntu镜像、创建虚拟机实例、完成系统安装和配置基础开发环境。安装VMware Tools增强了虚拟机的性能和用户体验。

### 1.2 网络配置
- 虚拟机采用NAT网络模式，确保可以访问外部网络以下载必要的软件包。通过执行`ping -c 4 baidu.com`测试网络连通性，并使用`sudo apt update`更新软件包列表。为提高下载速度，将软件源更换为阿里云镜像源。

### 1.3 GCC编译器安装
- 最初尝试安装最新的GCC 15.2.0编译器，通过添加第三方PPA仓库尝试获取预编译包，但发现Ubuntu 22.04官方仓库尚未提供该版本。转而尝试源码编译，但在配置和编译阶段遇到依赖问题。

- 最终选择安装Ubuntu官方仓库中的GCC 13.1.0版本，该版本稳定且功能完整。安装命令如下：
```bash
sudo apt install gcc-13 g++-13 libstdc++-13-dev -y
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-13 100
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-13 100
```
##二、排序算法实现细节

###2.1 快速排序算法

**递归版本实现**

- 递归快速排序采用挖坑法。算法核心是通过选择一个pivot元素将数组划分为两个区间，~~我规定的~~左区间所有元素都小于等于pivot，~~还是我规定的~~右区间所有元素都大于pivot，然后重新选择一个pivot继续挖坑填坑进行排序[^1]。

**本实现提供了两种pivot选择策略**

1.  随机选择：在待排序区间内随机选择一个元素作为pivot，可以避免在已排序或接近排序的数组上出现最坏情况。
2.  三数取中：选取待排序区间的首元素、中间元素和尾元素，取它们的中值作为pivot，在大多数情况下能避免最坏情况。

[^1]:分区过程使用Lomuto分区方案，从 区间左端开始遍历，将小于pivot的元素交换到区间左侧，大于pivot的元素留在右侧。

**非递归版本实现**

- 非递归快速排序使用显式栈来模拟递归过程，避免了函数调用的开销和递归深度限制问题。实现中定义了一个栈结构体来存储待排序的区间范围。

- 算法过程如下：

1.  将初始区间压入栈中
2.  循环从栈中弹出区间，进行分区操作
3.  将分区后的两个子区间压入栈中（如果子区间长度大于1）
4.  重复直到栈为空

- 这种方法在理论上可以减少函数调用开销，但实际测试中发现栈操作的开销可能抵消了这一优势。

###2.2 归并排序算法

**并行版本实现**

- 并行归并排序基于OpenMP多线程库实现，利用'#pragma omp parallel sections'指令将递归任务分配给不同线程执行。实现中设置了一个并行阈值（本实验使用1000），当待排序数组大小超过阈值时使用并行版本，否则使用串行版本以避免线程创建的开销。

- 并行化策略是将数组分成两半后，使用两个线程分别处理左右两半，然后在合并阶段同步。这种策略在数据量足够大时能够有效利用多核CPU的计算能力。
- 安装完成后，通过gcc --version验证安装成功，显示版本为13.1.0。

- 此外，还安装了构建工具、调试工具和OpenMP支持：

```bash
sudo apt install build-essential gdb valgrind libomp-dev -y
```

## 可视化说明

由于中文字体显示问题，最终采用英文标签的可视化图表，确保图表清晰可读。所有性能数据和结论分析保持不变。

### 图表说明
- **图1**: 四种排序算法在不同优化级别下的性能对比
- **图2**: 递归快速排序随优化级别的性能变化
- **图3**: 并行与串行归并排序性能对比  
- **图4**: Ofast优化相比O0的性能提升百分比


